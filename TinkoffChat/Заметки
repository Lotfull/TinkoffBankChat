
content hugging priority - для того, чтобы вьюхи с равноправными констрейнтами и не ясным поведением не враждовали, понижаем одной из них хаггин приорити и все четко, она подстраивается.

content compression resistance - сопротивляемость к сжатию - повысить = сказать вьюхе "если тебя кто-то захочет сжать, то не сжимайся!"

viewDidLoad не знает размеров, он все загружает, все данные и прочие, но еще не нарисовал.
viewWillAppear все что передал viewDidLoad рисует.
viewDidAppear уже все знает!

Работа с памятью на айоус

reference и value type


reference - обращение по ссылке (button)
в Хипе лежит память кнопки, и let b = UIButton - это указатель на память в Хипе

value - при копировании весь объект копируется
постоянно копируется при передаче в функции.
Лежат такие объекты в стеке

в iOS  не  гарбадж коллектор, а ARF - AutomaticReferenceCOunt - счестик ссылок

в свифт: let b1 = B()
в обджСи: [[B alloc] init] и освободить память - B.release() {еще есть retain}

Когда создали b1, на него ссылается одна ссылка b1.
При b2 = b1, теперь на него ссылаются 2 ссылки.

Проблема когда начинается retain cycle:
есть объекты A() и B()
{
b.a = a
a.b = b
}

Когда удалим a = nil, b = nil, бац - a и b на самом деле еще живут, но мы уже не сможем к ним иметь доступ!

Чтобы этого не произошло - делаем слабую ссылку при присвоении свойства a.b = b
То есть в классе А:
class A {
weal var b: B? - это слабая ссылка
var с: С? - это strong
}


Задание для крутанов: при тыкании на кнопку должен появлятся выбор фото из галереи либо сделать фото, выбрать, и оно опубликуется туда.




